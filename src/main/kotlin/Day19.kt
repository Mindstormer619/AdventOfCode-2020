import java.io.File
import java.lang.StringBuilder

class Day19(filename: String, replaceRules: Boolean = false) {
	private val ruleMap: Map<Int, Rule>
	private val messages: List<String>

	sealed class Rule {
		data class RuleChain(val ruleOptions: List<RuleList>): Rule()
		data class TerminalRule(val char: Char): Rule()
	}

	init {
		val lines = File(filename).readLines()

		val rules = mutableMapOf<Int, Rule>()
		val messages = mutableListOf<String>()
		nextLine@ for (line in lines) {
			when {
				line.isEmpty() -> { }
				line[0].isDigit() -> {
					val (idx, ruleString) = line.split(':')
					val rule: Rule = if (ruleString.endsWith('"')) {
						// process TerminalRule
						Rule.TerminalRule(ruleString[2])
					} else {
						val ruleLists = ruleString.split('|')
						Rule.RuleChain(ruleLists.map { ruleList -> ruleList.trim().split(' ').map { it.toInt() } })
					}

					rules[idx.toInt()] = rule
				}
				else -> {
					messages.add(line)
				}
			}
		}

		if (replaceRules) {
			rules[8] = Rule.RuleChain(listOf(listOf(42), listOf(42, 8)))
			rules[11] = Rule.RuleChain(listOf(listOf(42, 31), listOf(42, 11, 31)))
		}

		this.ruleMap = rules
		this.messages = messages
	}

	fun countMatchingMessages(): Int {
		var matchingMessages = 0
		for (message in messages) {
			if (message.matchesRule()) {
				matchingMessages++
			}
		}
		return matchingMessages
	}

	private fun String.matchesRule(): Boolean {
		val (result, parsedLength) = Parser(this, ruleMap).parse()
		return result && parsedLength == this.length
	}


	private class Parser(val message: String, val ruleMap: Map<Int, Rule>) {
		fun parse(ruleId: Int = 0, ptr: Int = 0): Pair<Boolean, Int> {
			if (ptr >= message.length) return false to ptr

			when (val rule = ruleMap[ruleId]!!) {
				is Rule.RuleChain -> {
					nextOption@ for (ruleList in rule.ruleOptions) {
						var p = ptr
						for (ruleIndex in ruleList) {
							val (result, newP) = parse(ruleIndex, p)
							if (result) p = newP
							else continue@nextOption
						}
						return true to p
					}
					return false to ptr
				}
				is Rule.TerminalRule -> {
					return if (message[ptr] == rule.char) true to ptr+1
					else false to ptr
				}
			}
		}
	}

	/*
	Make a regex for all rules EXCEPT rule 0, rule 8 and rule 11.
	Rule 8 is just 42 repeated
	Rule 11 is 42 repeated, 31 repeated... the same number of times.
	Rule 0 is just rule 8 followed by rule 11 in such a way that they satisfy the entire string.
	 */
	fun countMatchingMessagesWithReplacement(): Int {
		val ruleRegexes = mutableMapOf<Int, Regex>()

		for (ruleId in ruleMap.keys) {
			if (ruleId in listOf(0, 8, 11)) continue
			buildRuleRegexes(ruleId, ruleRegexes)
		}

		/*
		Rules 0, 8 and 11 are defined in this part of the problem as:
			0: 8 11
			8: 42 | 42 8
			11: 42 31 | 42 11 31

		This means that these rules cannot be directly expressed in regular expressions (well, Rule 8 can,
		but that's pointless without taking Rule 11 into account anyway, which can't). Instead, we exploit
		some simple observations about this piece of the problem.

		The observation we exploit is this: Rule 0 (which we're trying to eventually match) consists of
		Rule 8 followed by Rule 11. Rule 8 is a repeated sequence of Rule 42, while Rule 11 is a sequence
		of 42 followed by a sequence of 31, SUCH THAT the number of entries matching Rule 42 equals the number
		matching Rule 31, i.e.

			8 = 42 | 42 42 | 42 42 42 | 42 42 42 42...
			11 = 42 31 | 42 42 31 31 | 42 42 42 31 31 31 ...

		This means that Rule 0 (8 11) is basically a string of 42, followed by a string of 31, with the condition
		that **the number of matches of rule 42 is STRICTLY GREATER THAN number of matches of rule 31**.

		Think about that for a second. This is because we see at least one match of Rule 42 from 8, and then the
		number of matches generated by 11 are equal for both 42 and 31. Therefore, the count of 31 will always be
		less than 42, for the message to match.
		 */

		val rule42 = ruleRegexes[42]!!
		val rule31 = ruleRegexes[31]!!

		val rule0String = StringBuilder()
		rule0String.append('(')
		rule0String.append(rule42.pattern)
		rule0String.append(rule42.pattern)
		rule0String.append('+')
		rule0String.append(')')
		rule0String.append('(')
		rule0String.append(rule31.pattern)
		rule0String.append('+')
		rule0String.append(')')
		val rule0Regex = Regex(rule0String.toString())

		var count = 0
		for (message in messages) {
			if (rule0Regex.matches(message)) {
				val (rule42Match, rule31Match) = rule0Regex.matchEntire(message)!!.groupValues.subList(1, 3)
				val rule42Count = rule42.findAll(rule42Match).count()
				val rule31Count = rule31.findAll(rule31Match).count()
				if (rule31Count < rule42Count) count++
			}
		}
		return count
	}

	private fun buildRuleRegexes(ruleId: Int, ruleRegexes: MutableMap<Int, Regex>): Regex {
		if (ruleRegexes.containsKey(ruleId)) return ruleRegexes[ruleId]!!
		when (val rule = ruleMap[ruleId]!!) {
			is Rule.RuleChain -> {
				val ruleStringBuilder = StringBuilder()
				ruleStringBuilder.append("(?:")
				rule.ruleOptions.forEach { ruleOption ->
					ruleOption.forEach {
						ruleStringBuilder.append(buildRuleRegexes(it, ruleRegexes).pattern)
					}
					ruleStringBuilder.append('|')
				}
				ruleStringBuilder.deleteCharAt(ruleStringBuilder.lastIndex)
				ruleStringBuilder.append(')')
				ruleRegexes[ruleId] = Regex(ruleStringBuilder.toString())
			}
			is Rule.TerminalRule -> {
				ruleRegexes[ruleId] = Regex(rule.char.toString())
			}
		}
		return ruleRegexes[ruleId]!!
	}
}


private typealias RuleList = List<Int>